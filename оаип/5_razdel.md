# РАЗДЕЛ 5. ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ

## Тема 16. БАЗОВЫЕ ПОНЯТИЯ ОБЪЕКТНО-ОРИЕНТИРОВАННОЙ ТЕХНОЛОГИИ ПРОГРАММИРОВАНИЯ

**Объектно-ориентированное программирование (ООП)** — парадигма программирования, основанная на представлении программы в виде совокупности взаимодействующих объектов.

**Исторические аспекты развития ООП:**
- Первый ОО-язык — Simula-67 (1967)
- Развитие концепции — Smalltalk (1970-е)
- Популяризация — C++ (1980-е), Java (1990-е)
- Современные языки — C#, Python, JavaScript, Ruby и др.

**Основные понятия ООП:**

**Класс** — шаблон для создания объектов, определяющий их структуру и поведение.
- Определяет атрибуты (свойства) и методы (поведение)
- Является абстракцией некоторой сущности
- Может иметь конструкторы и деструкторы
- Содержит описание допустимых операций над объектами

**Объект** — экземпляр класса, сущность, обладающая состоянием и поведением.
- Создаётся на основе класса
- Занимает память во время выполнения программы
- Имеет собственное состояние (значения атрибутов)
- Обладает поведением, определенным в классе

**Свойства (поля)** — переменные, определяющие состояние объекта.
- Типизированные данные, связанные с объектом
- Представляют характеристики объекта
- Могут быть примитивных или сложных типов
- Могут иметь различные модификаторы доступа

**Методы** — функции, определяющие поведение объекта.
- Определяют операции над данными объекта
- Реализуют интерфейс взаимодействия с объектом
- Могут манипулировать свойствами объекта
- Могут возвращать значения и принимать параметры

**Основные принципы ООП:**

1. **Инкапсуляция** — сокрытие реализации и данных от внешнего вмешательства:
   - **Защита данных** от непреднамеренного изменения
     - Контроль доступа к полям класса
     - Предотвращение неверных изменений состояния объекта
   - **Объединение данных и методов** в единую сущность
     - Логическая группировка связанных данных и операций
     - Упрощение интерфейса взаимодействия
   - **Контролируемый доступ** через интерфейсы (геттеры, сеттеры)
     - Методы получения значений (getters)
     - Методы установки значений (setters) с проверкой корректности
   - **Преимущества инкапсуляции:**
     - Сокрытие внутренней реализации
     - Возможность изменения реализации без изменения интерфейса
     - Повышение надежности и стабильности кода

2. **Наследование** — механизм создания новых классов на основе существующих:
   - **Расширение функциональности** родительского класса
     - Добавление новых методов и свойств
     - Специализация поведения
   - **Повторное использование кода**
     - Избавление от дублирования кода
     - Использование готовой функциональности
   - **Иерархическая организация классов**
     - Базовые и производные классы
     - Отношение "является" (is-a)
   - **Виды наследования:**
     - Одиночное (один родитель)
     - Множественное (несколько родителей)
     - Многоуровневое (цепочка наследования)
     - Иерархическое (древовидная структура)

3. **Полиморфизм** — способность объектов с одинаковым интерфейсом иметь различные реализации:
   - **Переопределение методов** в дочерних классах
     - Изменение поведения унаследованных методов
     - Вызов реализации родительского класса через super/base
   - **Перегрузка методов** (методы с одинаковым именем, но разными параметрами)
     - Несколько методов с одним именем, но разной сигнатурой
     - Выбор конкретной реализации на основе типов параметров
   - **Динамическое связывание** (определение конкретного метода во время выполнения)
     - Позднее связывание (late binding)
     - Выбор реализации метода на основе типа объекта, а не типа ссылки
   - **Преимущества полиморфизма:**
     - Гибкость и расширяемость кода
     - Возможность работы с объектами разных классов через общий интерфейс
     - Упрощение взаимодействия компонентов системы

**Дополнительные принципы ООП:**

- **Абстракция** — выделение существенных характеристик объекта, отличающих его от других объектов
  - Сосредоточение на важных аспектах
  - Игнорирование несущественных деталей
  - Создание обобщенных типов и интерфейсов

- **Агрегация и композиция** — отношения между объектами
  - **Агрегация** — отношение "имеет" (has-a), при котором один объект содержит другой, но они могут существовать независимо
  - **Композиция** — более сильная форма агрегации, где составные объекты зависят от содержащего объекта и не могут существовать отдельно

## Тема 17. ОПИСАНИЕ КЛАССА

**Структура класса:**
- **Имя класса**
  - Идентификатор, уникально определяющий класс
  - Следует соглашениям об именовании (обычно PascalCase)

- **Секция объявления полей (свойств)**
  - Переменные-члены класса
  - Определяют состояние объектов
  - Типизированные данные различной природы
  - Могут иметь инициализаторы

- **Секция объявления методов**
  - Функции-члены класса
  - Определяют поведение объектов
  - Могут быть реализованы внутри или вне класса
  - Могут иметь различные спецификаторы и модификаторы

- **Спецификаторы доступа**
  - Определяют видимость членов класса
  - Контролируют доступ к данным и методам
  - Реализуют принцип инкапсуляции

**Синтаксические особенности описания класса в разных языках:**

**C++:**
```cpp
class ClassName {
private:
    // Приватные поля и методы
    int privateField;
    void privateMethod();
    
protected:
    // Защищенные поля и методы
    double protectedField;
    
public:
    // Публичные поля и методы
    ClassName(); // Конструктор
    ~ClassName(); // Деструктор
    void publicMethod();
};
```

**Java:**
```java
public class ClassName {
    // Приватные поля
    private int privateField;
    
    // Защищенные поля
    protected double protectedField;
    
    // Публичные поля
    public String publicField;
    
    // Конструктор
    public ClassName() {
        // Инициализация
    }
    
    // Методы
    private void privateMethod() {}
    protected void protectedMethod() {}
    public void publicMethod() {}
}
```

**Python:**
```python
class ClassName:
    # Конструктор
    def __init__(self):
        self._private_field = 0  # По соглашению приватное
        self.__really_private = 1  # Мангалинг имени
        self.public_field = "public"
    
    # Методы
    def public_method(self):
        pass
    
    def _private_method(self):  # По соглашению приватный
        pass
```

**Уровни инкапсуляции (спецификаторы доступа):**
- **Private** — доступ только внутри класса
  - Полное сокрытие от внешнего кода
  - Используется для внутренних деталей реализации
  - Обычно обозначается ключевым словом private

- **Protected** — доступ внутри класса и его потомков
  - Доступ ограничен классом и наследниками
  - Используется для функциональности, которая может быть переопределена
  - Обычно обозначается ключевым словом protected

- **Public** — доступ из любой части программы
  - Полная доступность для внешнего кода
  - Используется для определения интерфейса класса
  - Обычно обозначается ключевым словом public

- **Package/Internal** — доступ внутри пакета/модуля (в некоторых языках)
  - Доступ ограничен пакетом или модулем
  - Промежуточный уровень между protected и public
  - В Java - отсутствие модификатора доступа

**Создание и удаление объекта:**
- **Выделение памяти для объекта**
  - Динамическое выделение памяти (new в C++, Java)
  - Автоматическое выделение памяти для стековых объектов (C++)
  - Управление памятью средой выполнения (Java, Python)

- **Инициализация полей объекта**
  - Значения по умолчанию
  - Пользовательская инициализация через конструкторы
  - Списки инициализации (C++)

- **Освобождение памяти при уничтожении объекта**
  - Явное освобождение (delete в C++)
  - Автоматическое освобождение (сборка мусора в Java, Python)
  - Вызов деструкторов для освобождения ресурсов

**Присваивание объектов:**
- **Поверхностное копирование (копирование ссылок)**
  - Копирование только адреса объекта
  - Оба объекта указывают на одни и те же данные
  - Изменения в одном объекте видны через другой

- **Глубокое копирование (создание новых объектов)**
  - Создание полной копии данных объекта
  - Изменения в одном объекте не влияют на другой
  - Требует явной реализации (конструктор копирования, метод clone())

**Дружественность** — механизм, позволяющий классу или функции получать доступ к закрытым членам другого класса.
- **Дружественные функции**
  - Имеют доступ к приватным и защищенным членам класса
  - Объявляются внутри класса с ключевым словом friend (C++)
  - Не являются членами класса

- **Дружественные классы**
  - Весь класс имеет доступ к приватным и защищенным членам другого класса
  - Используется для тесно связанных классов
  - Нарушает принцип инкапсуляции, требует осторожного использования

**Статические члены класса:**
- **Статические поля**
  - Принадлежат классу, а не объекту
  - Одна копия на все объекты класса
  - Доступны без создания экземпляра класса

- **Статические методы**
  - Не имеют доступа к нестатическим членам класса
  - Не могут использовать this/self
  - Работают с классом в целом, а не с конкретным объектом

## Тема 18. МЕТОДЫ КЛАССА. ИНИЦИАЛИЗАЦИЯ И РАЗРУШЕНИЕ

**Типы методов класса:**

- **Статические (class)** — принадлежат классу, а не объекту; не имеют доступа к нестатическим членам класса
  - Объявляются с ключевым словом static
  - Вызываются через имя класса, а не через объект
  - Используются для операций, связанных с классом в целом
  - Примеры использования: фабричные методы, утилитные функции

- **Виртуальные (virtual)** — могут быть переопределены в дочерних классах; обеспечивают полиморфное поведение
  - Объявляются с ключевым словом virtual (C++), или по умолчанию (Java)
  - Реализуют механизм позднего связывания
  - Конкретная реализация определяется во время выполнения
  - Основа для полиморфизма подтипов

- **Чисто виртуальные (абстрактные)** — не имеют реализации; должны быть переопределены в дочерних классах
  - Объявляются с = 0 (C++), или с ключевым словом abstract (Java, C#)
  - Класс с чисто виртуальными методами становится абстрактным
  - Невозможно создать экземпляр абстрактного класса
  - Обязывают дочерние классы предоставить реализацию

- **Динамические** — определяются во время выполнения программы
  - Механизм динамической диспетчеризации
  - Связываются с объектом во время выполнения
  - Обеспечивают гибкость и расширяемость

- **Перегружаемые** — методы с одинаковым именем, но различными параметрами
  - Разная сигнатура (типы и количество параметров)
  - Выбор конкретного метода на основе аргументов
  - Обеспечивают удобство использования и понятный интерфейс
  - Не связаны с наследованием и полиморфизмом

- **Финальные (final)** — не могут быть переопределены в дочерних классах
  - Объявляются с ключевым словом final (Java, C#), или sealed (C++)
  - Предотвращают изменение поведения в наследниках
  - Используются для критически важных методов, не требующих изменения

**Особые методы класса:**
- **Конструкторы** — специальные методы для инициализации объектов
- **Деструкторы** — специальные методы для освобождения ресурсов
- **Операторные методы** — перегрузка операторов для работы с объектами
- **Методы доступа** — геттеры и сеттеры для контролируемого доступа к полям

**Инициализация и разрушение объекта:**

**Конструкторы** — специальные методы для инициализации объектов:
- **Назначение:**
  - Инициализация полей объекта
  - Выделение ресурсов
  - Установление начального состояния

- **Характеристики:**
  - Вызываются при создании объекта
  - Имеют то же имя, что и класс (в большинстве языков)
  - Не имеют возвращаемого типа
  - Могут быть перегружены (с разными параметрами)

- **Виды конструкторов:**
  - **Конструктор по умолчанию** — без параметров
  - **Параметризованный конструктор** — с параметрами
  - **Конструктор копирования** — создает копию объекта
  - **Конструктор перемещения** — перемещает ресурсы из другого объекта (C++)

- **Списки инициализации** (C++):
  - Синтаксис: Constructor() : field1(value1), field2(value2) {}
  - Более эффективны, чем присваивание в теле конструктора
  - Обязательны для инициализации константных полей и ссылок

- **Делегирующие конструкторы**:
  - Вызывают другой конструктор того же класса
  - Уменьшают дублирование кода
  - Обеспечивают единую точку инициализации

**Деструкторы** — специальные методы для освобождения ресурсов:
- **Назначение:**
  - Освобождение динамически выделенной памяти
  - Закрытие файлов и сетевых соединений
  - Освобождение других системных ресурсов

- **Характеристики:**
  - Вызываются при уничтожении объекта
  - В C++ имеют имя класса с префиксом ~ (например, ~ClassName())
  - В Java используется метод finalize() (устаревший)
  - В языках с автоматической сборкой мусора используются реже

- **Особенности:**
  - Не имеют параметров и возвращаемого значения
  - Не могут быть перегружены
  - В C++ можно объявить виртуальным для правильного разрушения объектов через указатель на базовый класс

- **Шаблон RAII** (Resource Acquisition Is Initialization):
  - Принцип управления ресурсами в C++
  - Ресурсы выделяются в конструкторе
  - Ресурсы освобождаются в деструкторе
  - Обеспечивает корректное освобождение ресурсов даже при исключениях

**Интерфейсы и абстрактные классы:**

- **Интерфейс** — контракт, определяющий набор методов без реализации
  - Содержит только сигнатуры методов
  - Не содержит полей (кроме констант в некоторых языках)
  - Класс может реализовывать множество интерфейсов

- **Абстрактный класс** — класс, содержащий хотя бы один абстрактный метод
  - Может содержать как абстрактные, так и конкретные методы
  - Может иметь поля и конструкторы
  - Не может быть инстанцирован напрямую

**Паттерны проектирования в ООП:**

- **Порождающие паттерны**:
  - Фабрика (Factory) — создание объектов без указания конкретного класса
  - Одиночка (Singleton) — гарантирует существование только одного экземпляра класса
  - Строитель (Builder) — пошаговое создание сложных объектов

- **Структурные паттерны**:
  - Адаптер (Adapter) — совместимость несовместимых интерфейсов
  - Декоратор (Decorator) — динамическое добавление функциональности
  - Фасад (Facade) — упрощенный интерфейс для сложной системы

- **Поведенческие паттерны**:
  - Наблюдатель (Observer) — оповещение объектов об изменениях
  - Стратегия (Strategy) — взаимозаменяемые алгоритмы
  - Команда (Command) — инкапсуляция запросов как объектов

**SOLID принципы объектно-ориентированного проектирования:**

- **S** — Single Responsibility (Принцип единственной ответственности)
  - Каждый класс должен иметь только одну причину для изменения
  - Фокусирует класс на решении одной задачи

- **O** — Open/Closed (Принцип открытости/закрытости)
  - Классы должны быть открыты для расширения, но закрыты для модификации
  - Новая функциональность добавляется путем создания новых классов

- **L** — Liskov Substitution (Принцип подстановки Барбары Лисков)
  - Объекты базового класса могут быть заменены объектами производных классов без нарушения корректности программы
  - Поддержка полиморфного поведения

- **I** — Interface Segregation (Принцип разделения интерфейса)
  - Клиенты не должны зависеть от методов, которые они не используют
  - Предпочтительно много специализированных интерфейсов вместо одного общего

- **D** — Dependency Inversion (Принцип инверсии зависимостей)
  - Высокоуровневые модули не должны зависеть от низкоуровневых
  - Оба типа модулей должны зависеть от абстракций
  - Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций 